import os, sys, traceback, time

LOG = "run_log.txt"
ERR = "error_log.txt"

def log(msg):
    with open(LOG, "a", encoding="utf-8") as f:
        f.write(msg + "\n")
    print(msg, flush=True)

def setup_matplotlib():
    import matplotlib
    INTERACTIVE=False
    plt=None
    for cand in ["TkAgg","Qt5Agg","QtAgg","MacOSX"]:
        try:
            matplotlib.use(cand, force=True)
            import matplotlib.pyplot as plt  # noqa
            INTERACTIVE=True
            log(f"[matplotlib] Using interactive backend: {cand}")
            return matplotlib, plt, INTERACTIVE
        except Exception:
            plt=None
    # Fallback
    matplotlib.use("Agg", force=True)
    import matplotlib.pyplot as plt  # noqa
    INTERACTIVE=False
    log("[matplotlib] Using non-interactive backend: Agg")
    return matplotlib, plt, INTERACTIVE

def train_and_plot():
    # Torch imports
    import torch
    import torch.nn as nn
    import torch.optim as optim
    from torchvision import datasets, transforms
    from torch.utils.data import DataLoader

    log("torch version: " + torch.__version__)

    # Section 1: Tensors
    log("Section 1: Tensors & Arrays")
    img = torch.rand(28,28)
    batch = torch.rand(64,1,28,28)
    rgb = torch.rand(16,3,64,64)
    log(f"img {tuple(img.shape)} batch {tuple(batch.shape)} rgb {tuple(rgb.shape)}")
    log("(N,C,H,W) = Batch, Channels, Height, Width; grayscale C=1, RGB C=3")

    # Section 2: Network
    log("Section 2: Feedforward Neural Network")
    ffnn = nn.Sequential(nn.Flatten(), nn.Linear(28*28,128), nn.ReLU(), nn.Linear(128,10))
    log(repr(ffnn))

    # Section 3: Training
    log("Section 3: Training MNIST (3 epochs)")
    transform = transforms.Compose([transforms.ToTensor()])
    train_data = datasets.MNIST(root="./data", train=True, download=True, transform=transform)
    test_data  = datasets.MNIST(root="./data", train=False, download=True, transform=transform)

    train_loader = DataLoader(train_data, batch_size=64, shuffle=True)
    test_loader  = DataLoader(test_data, batch_size=1000, shuffle=False)

    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    log("device=" + str(device))

    model = ffnn.to(device)
    criterion = nn.CrossEntropyLoss()
    optimizer = optim.Adam(model.parameters(), lr=1e-3)

    losses=[]; accs=[]

    for epoch in range(3):
        model.train(); running=0.0
        for x,y in train_loader:
            x,y = x.to(device), y.to(device)
            optimizer.zero_grad()
            out = model(x)
            loss = criterion(out,y)
            loss.backward()
            optimizer.step()
            running += loss.item()
        avg = running/len(train_loader); losses.append(avg)

        model.eval(); correct=0; total=0
        with torch.no_grad():
            for x,y in test_loader:
                x,y = x.to(device), y.to(device)
                out = model(x)
                pred = out.argmax(dim=1)
                total += y.size(0); correct += (pred==y).sum().item()
        acc = 100.0*correct/total; accs.append(acc)
        log(f"Epoch {epoch+1}: loss={avg:.4f} acc={acc:.2f}%")

    # Section 4: Plots
    import matplotlib.pyplot as plt
    out_dir = os.path.abspath(".")
    loss_png = os.path.join(out_dir, "training_loss.png")
    acc_png  = os.path.join(out_dir, "test_accuracy.png")

    plt.figure()
    plt.plot(losses, label="Training Loss")
    plt.xlabel("Epoch"); plt.ylabel("Loss"); plt.title("Training Loss over Epochs"); plt.legend()
    plt.savefig(loss_png, dpi=150, bbox_inches="tight")

    plt.figure()
    plt.plot(accs, label="Test Accuracy (%)")
    plt.xlabel("Epoch"); plt.ylabel("Accuracy (%)"); plt.title("Test Accuracy over Epochs"); plt.legend()
    plt.savefig(acc_png, dpi=150, bbox_inches="tight")

    log("Saved plots:")
    log(" - " + loss_png)
    log(" - " + acc_png)
    return loss_png, acc_png

def math_deep_dive():
    import torch
    log("Section 5: Math Deep Dive â€” Gradient Check")
    # Simple scalar objective: L = (W @ x - 1)^2
    x = torch.randn(3, requires_grad=True)
    W = torch.randn(1, 3, requires_grad=True)

    y = W @ x
    loss = (y - 1) ** 2
    loss.backward()  # autograd

    analytic = x.grad.detach().clone()
    # Finite difference numeric gradient
    eps = 1e-5
    num_grad = torch.zeros_like(x)
    for i in range(3):
        x_ = x.detach().clone()
        x_[i] += eps
        loss_pos = ((W @ x_ - 1) ** 2).item()
        x_[i] -= 2*eps
        loss_neg = ((W @ x_ - 1) ** 2).item()
        num_grad[i] = (loss_pos - loss_neg) / (2*eps)

    agreement = torch.allclose(analytic, num_grad, atol=1e-4)
    log("Analytic grad: " + str(analytic.tolist()))
    log("Numeric grad : " + str(num_grad.tolist()))
    log("Agreement    : " + str(bool(agreement)))

def main():
    # fresh logs
    for p in (LOG, ERR):
        try:
            if os.path.exists(p):
                os.remove(p)
        except:
            pass

    log("=== START DL Fundamentals (Complete) ===")
    log("cwd=" + os.path.abspath("."))
    log("python=" + sys.executable)
    log("time=" + time.strftime("%Y-%m-%d %H:%M:%S"))

    # Matplotlib
    matplotlib, plt, INTERACTIVE = setup_matplotlib()
    log("matplotlib version: " + matplotlib.__version__)

    # Train & plot
    loss_png, acc_png = train_and_plot()

    # Math Deep Dive
    math_deep_dive()

    # Try show
    if INTERACTIVE:
        try:
            plt.show()
        except Exception as e:
            log("plt.show() failed: " + str(e))

    # Auto-open on Windows
    if os.name == "nt":
        try:
            os.startfile(loss_png)  # type: ignore
            os.startfile(acc_png)   # type: ignore
            log("Auto-opened images via default viewer.")
        except Exception as e:
            log("Auto-open failed: " + str(e))

    log("=== END ===")

if __name__ == "__main__":
    try:
        main()
    except Exception:
        with open(ERR, "w", encoding="utf-8") as f:
            traceback.print_exc(file=f)
        print("An error occurred. See error_log.txt for details.")
        raise
    finally:
        try:
            input("\nPress Enter to exit...")
        except Exception:
            pass


